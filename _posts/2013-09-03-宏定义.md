---
layout: post
title: "宏定义"
date: 2013-09-03
comments: false
categories: 基础知识
---

##1.预处理指令
 - 什么是预处理指令:
    - 在我们的文件翻译成0和1之前做的操作我们称之为预处理指令
    - 一般情况预处理指令都是以#号开头的
 宏定义

 条件编译
 文件包含

### 2.宏定义的作用:
会在程序翻译成0和1之前, 将所有宏名替换为 宏的值

### 3.宏定义在什么时候替换
 源代码 --> 预处理 -->汇编 -->二进制 -->可执行程序

###4.规范:
 - 一般情况宏名都大写, 多个单词之间用_隔开, 并且每个单词全部大写
 - 有得公司又要求宏名以k开头, 多个单词之间用驼峰命名

###5.注意:
宏定义后面不要写分好

###6.宏定义也有作用域
 - 从定义的那一行开始, 一直到文件末尾
 - 虽然默认情况下宏定义的作用域是从定义的那一行开始, 一直到文件末	尾. 但是我们也可以通过对应的关键字提前结束宏定义的作用域



### 宏定义的格式
- 1.不带参数的宏定义
- 2.带参数的宏定义

####不带参数的宏定义

```c
 #define 宏名 值
 例：
 	#define COUNT 998




// 提前结束宏定义的作用域
//#undef 宏名称
例：
	#undef COUNT

// 如果宏名写在双引号中, 那么不会被替换
    printf("COUNT");

```
####带参数的宏定义

```c
 #define SUM(v1, v2) v1+v2

 #define 代表要定义一个宏
 SUM 宏的名称
 (v1, v2) 参数, 注意点, 不需要写数据类型
 v1+v2 用于替换的内容

 宏定义并不会做任何运算, 无论是有参数还是没有参数都仅仅是在翻译成0和1之前做一个简单的"替换"

 带参数的宏定义注意点
 1.一般情况下建议写带参数的宏的时候, 给每个参数加上一个()
 2.一般情况下建议写带参数的宏的时候, 给结果也加上一个()

```
#条件编译

```
 条件编译和选则结构if的共同点:
 都可以对给定的条件进行判断, 添加满足或者不满足都可以执行特定的代码

 条件编译和选则结构if的共区别:
 1.生命周期不同
    if 运行时
    #if 编译之前
 2.#if需要一个明确的结束符号 #endif
    为什么需要一个明确的结束符号?
    如果省略掉#endif, 那么系统就不知道条件编译的范围, 那么会将满足条件之后的第二个条件之后的所有内容都清除
 3.if会将所有的代码都编译到二进制中
  #if只会将满足条件的部分一直到下一个条件的部分 编译到二进制中

 条件编译的优点
 1.缩小应用程序的大小

 应用场景:
 用于调试和发布阶段进行测试
 调试阶段: 程序写代码的阶段
 发布阶段: 上传到AppStore的阶段

	#if
	#elif
	#else
	#endif

	#ifdef
	#else
	#endif

	#ifndef
	#else
	#endif
```
---
##宏定义扩展:
  
- **宏定义里#仅仅是加双引号的作用**
- **宏定义里##是连接#两边内容的作用**

```
#define BWTest(name) @#name
#的作用仅仅是加"",       @#name--->@"name"

#define BWTest(name) test##name
##的作用是连接#两边,    test##name--->testname
```

---

#typedef
###c语言中,只看const右边是谁,在const右边的都是常量,不能修改
```
什么是typedef, 它有什么作用
 typedef可以给一个已知的数据类型起别名 (外号)

 利用typedef给数据类型起别名的格式:

 typedef 原有的数据类型 别名(外号);

 注意:

 1. typedef不仅能给系统原有的数据类型起别名, 也可以给一个自定义的数据类型起别名

 2. 利用typedef给数据类型起别名, 并不会生成一个新的数据类型, 仅仅是给原有的类型起了一个别名而已

 3. ***如果是给指向函数的指针起别名, 那么指向函数的指针的指针名称就是它的别名***
 typedef int(*functionPotinter)(int , int);
// functionPotinter == int(*functionPotinter)(int , int)
```

#const
###c语言中,只看const右边是谁,在const右边的都是常量,不能修改
```
如果const写在指针类型的左边, 那么意味着指向的内存空间中的值不能改变, 但是指针的指向可以改变
const int *p1;

如果const写在指针的数据类型和*号之间, 那么意味着指向的内存空间中的值不能改变, 但是指针的指向可以改变
int const *p2;

如果const写在指针的右边(数据类型 * const), 那么意味着指针的指向不可以改变, 但是指针指向的存储空间中的值可以改变
int *const p3;
```

- **规律**:
    + 如果const写在指针变量名的旁边, 那么指针的指向不能变, 而指向的内存空间的值可以变

    + 如果const写在数据类型的左边或者右边, 那么指针的指向可以改变, 但是指向的内存空间的值不能改变