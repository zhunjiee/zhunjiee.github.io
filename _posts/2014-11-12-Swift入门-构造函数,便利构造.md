---
layout: post
title: "Swift入门-构造函数,便利构造"
date: 2014-11-12
comments: false
categories: Swift
---

#构造函数



一个对象在初始化时必须给所有的成员变量赋值



- 注意点: 

	- 如果自定义一个对象, 而对象的属性如果又是基本数据类型, 那么不建议设置为可选类型, 而是应该赋值为0, 或者-1



总结规律: 



- **对象类型设置为可选类型, 基本数据类型赋值初始值**



- 自定义构造方法之前要先重写默认的构造方法



- 如果想在Swift的构造方法中使用KVC, 必须先手动调用`super.init()`



##利用KVC字典转模型

Person.swift



```

class Person: NSObject {

	// 一个对象在初始化时必须给所有的成员变量赋值

	var name: String?

    var age: Int = -1 // 如果自定义一个对象, 而对象的属性如果又是基本数据类型, 那么不建议设置为可选类型, 而是应该赋值为0, 或者-1

    

    // 如果既没有重写也没有自定义, 那么系统会给我们提供一个默认的构造方法

    // 如果自定了构造方法, 并且没有重写默认构造方法, 那么系统默认的构造方法就会失效



    // 重写父类构造方法

    // 以后但凡看到override, 就代表是重写父类的

    override init() {

        name = "lnj"

        age = 30

        // 系统悄悄咪咪的帮我们调用了一次super.init()

//        super.init()

    }



    // 自定义构造

    init(name: String, age: Int)

    {

        self.name = name

        self.age = age

    }

    

    

    

    /***** 下面的代码即是标准形式 *****/

    init(dict: [String: AnyObject])

    {

        // 注意: 如果想在Swift的构造方法中使用KVC, 必须先手动调用super.init

        super.init()

        setValuesForKeysWithDictionary(dict)

    }

    

    // 如果利用KVC赋值, 但是字典和模型的属性不能一一对应, 就会调用下面这个方法

    override func setValue(value: AnyObject?, forUndefinedKey key: String) {



    }

    // 只要重写这个属性, 就相当于OC中重写description方法

    override var description: String {

        // 优化

        let property = ["name", "age"]

        let dict =  dictionaryWithValuesForKeys(property)

        return "\(dict)"

//        return "name = \(self.name), age = \(self.age)"

    }



}

```

自定义控件的初始化方法



```

    /**
     自定义控件的初始化方法
     */
    override init(frame: CGRect) {
        super.init(frame: frame)
        
        backgroundColor = UIColor.redColor()
        
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
```








注意: Swift中如果文件是在同一个项目中, 那么可以不用导入头文件



为什么不用导入?



-  Swift中提供了一个叫做**命名空间**的概念, 只要在同一个命名空间中都可以直接使用

- 默认情况下, 项目名称就是命名空间

    

开发技巧:



- 正是因为有了命名空间, 所以以后在做Swift开发时所有三方框架都使用cocoapods集成,

- 如果使用cocoapods集成框架, 那么cocoapods会自动生成一个新的项目



ViewController.swift



```

class ViewController: UIViewController {



    override func viewDidLoad() {

        super.viewDidLoad()

                

    let p = Person()

    let p = Person(name: "zs", age: 55)

    print(p.name)

    print(p.age)

    print(p)

    

    let p = Person(dict: ["name": "lnj", "age": 88, "score": 59.5])

    print(p)

    }

}

```





#便利构造方法

应用场景:



- 当我们通过extension扩展方式(类似OC中Category)为原有类扩充方法时,有时候需要扩充构造方法用于创造对象

- 只要在构造方法前面加上**convenience**单词, 那么这就是一个便利构造方法

- 便利构造方法: **仅仅是对原有构造方法的扩充, 主要是为了方便创建对象**





**指定构造方法**: `init(xxx:xxx)`



- 1.必须调用"父类"super.init()初始化

- 2.默认情况下系统会自动帮调用(编译器隐式的帮我们自动添加了一行super.init())



**便利构造方法**: `convenience init(xxx:xxx)`



- 1.必须调用"当前类"的指定构造方法

- 2.不能调用super.init()

- 3.也可以调用其他的便利构造方法, 但是其它构造方法中必须调用本类的指定构造方法



##类函数

普通对象函数: **func**



类函数: **class func**





##案例:

例如我们为UIButton类扩展方法,用于创建自定义的按钮,这时我们就会用到便利构造方法



```

import UIKit



extension UIButton

{

//    func       == OC  -

//    class func == OC +

    /*

    // 垃圾

    class func createButton(imageName: String, backgroundImage: String) -> UIButton

    {

        let btn = UIButton()

        

        btn.setImage(UIImage(named: imageName), forState: UIControlState.Normal)

        btn.setImage(UIImage(named: imageName + "_highlighted"), forState: UIControlState.Highlighted)

        

        btn.setBackgroundImage(UIImage(named: backgroundImage), forState: UIControlState.Normal)

        btn.setBackgroundImage(UIImage(named: backgroundImage + "_highlighted"), forState: UIControlState.Highlighted)

        

        btn.sizeToFit()

        return btn

    }

    */

    

    // 只要在构造方法前面加上convenience单词, 那么这就是一个便利构造方法

    // 便利构造方法: 仅仅是对原有构造方法的扩充, 主要是为了方便创建对象

    convenience init(imageName: String, backgroundImage: String)

    {

        self.init()

        setImage(UIImage(named: imageName), forState: UIControlState.Normal)

        setImage(UIImage(named: imageName + "_highlighted"), forState: UIControlState.Highlighted)

        

        setBackgroundImage(UIImage(named: backgroundImage), forState: UIControlState.Normal)

        setBackgroundImage(UIImage(named: backgroundImage + "_highlighted"), forState: UIControlState.Highlighted)

        

        sizeToFit()

    }

}

```



##required修饰符的使用规则

1. required修饰符只能用于修饰类初始化方法。

2. 当子类含有异于父类的初始化方法时（初始化方法参数类型和数量异于父类），子类必须要实现父类的required初始化方法，并且也要使用required修饰符而不是override。
3. 当子类没有初始化方法时，可以不用实现父类的required初始化方法。
