---
layout: post
title: "iOS页面之间的传值总结"
date: 2014-04-19
comments: false
categories: 知识囊
---
##1、属性传值

####（1）: 属性传值第一步需要用到什么类型就定义什么样的属性

####（2）: 从上一个页面到一个页面的选中方法里面将要传的值传到来（上一个页面）备注：这种方法只适用于上一个页面推到下一个页面。

如：MainViewController与SecondViewController两个视图控制器，点击MainViewController中的按钮将跳转到SecondViewController视图，同时想要传递一个值过去。这时可以利用属性传值。



首先SecondViewController视图中需要有一个属性用来 存储传递过来的值：

```
@property(nonatomic,retain) NSString *firstValue ;//属性传值
```


然后MainViewController视图需要引用SecondViewController视图的头文件，在视图中的按钮点击事件中，通过SecondViewController的对象将需要传递的值存在firstValue中:


```
(void)buttonAction:(UIButton *)button{

    SecondViewController *second = [[SecondViewController alloc]init];//用下一个视图的属性接受想要传过去的值,属性传值

    second.firstValue = _txtFiled.text;

    [self.navigationController pushViewController:second animated:YES];

}
```


页面跳转之后，就能在SecondViewController视图中，通过存值的属性，取用刚才传递过来的值：

//显示传过来的值[_txtFiledsetText:_firstValue];//firstValue保存传过来的值



##2、通知传值

如果在一个类中想要执行另一个类中的方法可以使用通知

###通知中心
NSNotificationCenter提供了一种更加解耦的方式。最典型的应用就是任何对象都可以发送通知到中心，同时任何对象可以监听中心的通知。


发送通知的代码如下：

```
[[NSNotificationCenter    defaultCenter]     postNotificationName:@”myNotificationName”    object:broadcasterObject];
```

注册接收通知的代码如下：

```
[[NSNotificationCenter    defaultCenter]     addObserver:listenerObject     selector:@selector(receivingMethodOnListener:)     name:@”myNotificationName”    object:nil];
```

注册通知的时候可以指定一个具体的广播者对象，但这不是必须的。你可能注意到了defaultCenter。实际上这是你在应用中会使用到的唯一的中心。通知会向整个应用开放，因此只有一个中心。
同时还有一个NSDistributedNotificationCenter。这是用来应用间通信的。在整个计算机上只有一个该类型的中心。


>**优点**: 通知的发送者和接受者都不需要知道对方。可以指定接收通知的具体方法。通知名可以是任何字符串。

>**缺点**: 较键值观察需要多点代码。在删掉前必须移除监听者。不能传大量数值，只能让谁去做什么事。



##3、代理协议传值

####（1）、协议（protocol），就是使用了这个协议后，必须按照协议规定的内容来处理事情，协议中要求的方法必须实现（@optional的方法除外）。

protocol是一种语法，它提供了一个很方便的、实现delegate模式的机会。



定义protocol如下：

```
@protocol ClassBDelegate<NSObject>
 
- (void)methodOne; 
@optional 
- (void)methodTwo:(NSString *)value;
  
@end
```


定义了一个ClassB的协议，这个协议中包含两个方法，其中methodTwo为可选的。

在ClassA的头文件（ClassA.h）中实现这个协议，如下代码：

```
@interface ClassA<ClassBDelegate> 

@end
```


在ClassA的实现文件（ClassA.m）中实现ClassBDelegate的两个方法，其中methodTwo可以不实现，如下：

```
- (void)methodOne{ 

     // 具体实现内容 
 } 

  

- (void)methodTwo:(NSString *)value{  

    // 具体实现内容   

 }
```


####（2）、代理（delegate），顾名思义就是委托别人办事，当一件事情发生后，自己不处理，让别人来处理。

delegate和protocol没有关系。delegate本身是一种设计模式。是把一个类自己需要做的一部分事情，让另一个类（也可以就是自己本身）来完成。



在ClassB的头文件（ClassB.h）中定义一个代理如下：

```
@interface ClassB 
@property (nonatomic, unsafe_unretained) id<ClassBDelegate> delegate; 
@end 
```

这样，当我们在ClassB的实现文件（ClassB.m）中遇到想让别的类（如 ClassA）处理的问题时，就可以这样

```
[self.delegate methodOne];

[self.delegate methodTwo:@"需要传递的值"];        
```