---
layout: post
title: "Swift入门-闭包"
date: 2014-11-10
comments: false
categories: Swift
---

##什么是闭包?

* 闭包和OC中的Block很像

* OC中的Block类似于匿名函数

* Swift中的闭包就是一个特殊的函数

        

Block一般用于回调, 异步准备数据, 然后通过Block回调更新UI



    

###Block格式:

- 类型:

<pre>

返回值类型(^Block名称)(形参列表)

</pre>



- 值:

<pre>

^(形参列表){

  // 逻辑代码

}

</pre>

    



###闭包格式:

- 类型:

<pre>

(形参列表)->返回值

</pre>



- 值:

	- in的作用就是用于分隔逻辑代码和描述

<pre>

{ 

(形参列表) -> 返回值类型  in

    // 逻辑代码

}

</pre>





##闭包的简写

* 如果没有返回值也没有参数, 那么in和in之前的代码可以删除

* 如果闭包所形参列表的最后一个参数, 那么可以把闭包写到()后面

* 如果函数只有一个形参, 并且这个形参是一个闭包, 那么()可以不写





```    

    loadData ({ () -> () in

        print(NSThread.currentThread())

        print("回到主线程更新UI")

    })

    

    // 如果没有返回值也没有参数, 那么in和in之前的代码可以删除

    loadData ({

        print(NSThread.currentThread())

        print("回到主线程更新UI")

    })

    

// 以下两种写法, 我们称之为尾随闭包

    loadData (){

        print(NSThread.currentThread())

        print("回到主线程更新UI")

    }

    

    // 开发中建议写下面这一种写法

    loadData {

        print(NSThread.currentThread())

        print("回到主线程更新UI")

    }

```



```

func loadData(myBlock: ()->())

{

    dispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in

        print(NSThread.currentThread())

        print("异步准备数据")

        

        dispatch_async(dispatch_get_main_queue(), { () -> Void in

            myBlock()

        })

    }

}

```

#闭包的循环引用



闭包里面用self有时会造成循环引用问题,但在闭包最后有( )代表执行闭包,代码执行完就完事了,就不会有强引用了





##如何解决循环引用

**OC中**: `__weak typeof(self) weakSelf = self;`



// 因为变量是weak的, 随时有可能被释放, 所以系统推导是可选类型

        

**Swift中**: `weak var weakSelf = self`




##如何解决循环引用?        

1. Swift中的weak对应OC中的__weak, 如果对象释放了, 那么会自动将变量赋值为nil



2. 使用[weak self] 修饰闭包原理跟__weak类似, 这样在闭包中使用self, 就是弱引用



3. Swift中的`unowned`对应OC中的 `__unsafe_unretained`,  如果对象释放了, 不会将变量赋值为nil, 如果对象释放了再继续访问会出现野指针错误, 缺点不安全



```



//解决方式三: [unowned self]  跟 _unsafe_unretained 类似  不推荐使用 
        loadData { [unowned self] (dataString) -> () in
            print("\(dataString) \(self.view)")
        }  
    }

    func method2() {
        //解决方式二:  在swift中 有特殊的写法 ,跟OC __weak 相似  [weak self]
        loadData { [weak self] (dataString) -> () in

            //以后在闭包中中 使用self 都是若引用的
            print("\(dataString) \(self?.view)")
        }
    }

    func method1() {
        // 解决方式一: weak
        weak var weakSelf = self
        loadData { (dataString) -> () in
            print("\(dataString) \(weakSelf?.view)")
        }
    }
```



**有大神说开发中推荐用方式三这样写**

<pre>

        loadData { [unowned self] () -> () in

            print(NSThread.currentThread())

            print("回到主线程更新UI")

            self.view.backgroundColor = UIColor.redColor()

        }

</pre>





```

class ViewController: UIViewController {



    // 报错的原因: Swift规定一个对象中的属性必须在对象初始化时全部初始化

    // 如果没有在初始化时给所有的属性赋值, 那么就会报错

    // 要想不报错, 那么可以让属性变成可选的

    

    // 注意: 错误写法()->()? , 这中写法代表闭包的返回值是可选的, 而不是闭包是可选的

    // 可选类型的值, 如果没有初始化, 那么默认值就是nil

    var finished: (()->())?

    

    override func viewDidLoad() {

        super.viewDidLoad()



        view.backgroundColor = UIColor.purpleColor()

    }



    override func touchesBegan(touches: Set<UITouch>, withEvent event: UIEvent?) {

        

        /*

        OC中: __weak typeof(self) weakSelf = self;

        // 因为变量是weak的, 随时有可能被释放, 所以系统推导是可选类型

        Swift中: weak var weakSelf = self

        

        Swift中的weak对应OC中的__weak, 如果对象释放了, 那么会自动将变量赋值为nil

        Swift中的unowned对应OC中的__unsafe_unretained,  如果对象释放了, 不会将变量赋值为nil, 如果对象释放了再继续访问会出现野指针错误

        */

       

        // 开发中推荐这样写

        loadData { [unowned self] () -> () in

            print(NSThread.currentThread())

            print("回到主线程更新UI")

            self.view.backgroundColor = UIColor.redColor()

        }

    }

    

    func loadData(myBlock: ()->())

    {

        dispatch_async(dispatch_get_global_queue(0, 0)) { () -> Void in

            print(NSThread.currentThread())

            print("异步准备数据")

            

            dispatch_async(dispatch_get_main_queue(), { () -> Void in

                self.finished = myBlock

                myBlock()

            })

        }

    }

    

    // OC : dealloc

    // Swift: deinit

    deinit

    {

        // 只要对象释放就会调用这个方法

        print("滚")

    }



}

```

