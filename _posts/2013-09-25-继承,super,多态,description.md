---
layout: post
title: "继承,super,多态,description"
date: 2013-09-25
comments: false
categories: ObjC
---

#继承相关特性

##1.方法重写

- 在子类中实现与父类中同名的方法，称之为方法重写；
- 重写以后当给子类发送这个消息的时候，执行的时在子类中重写的那个方法，而不是父类中的方法。

- 如果在想在子类中调用被子类重写的父类的方法，可以通过super关键字

- 使用场景：当从父类继承的某个方法不适合子类,可以在子类中重写父类的这个方法。

##2.继承中方法调用的顺序

1. 在自己类中找
2. 如果没有,去父类中找
3. 如果父类中没有,就去父类的父类中
4. 如果父类的父类也没有,就还往上找,直到找到基类(NSObject)
5. 如果NSObject都没有就报错了

如果找到了就执行这个方法，就不再往后查找了

##3.继承的注意事项

- 子类不能定义和父类同名的成员变量，私有成员变量也不可以；因为子类继承父类，子类将会拥有父类的所有成员变量，若在子类中定义父类同名成员变量 属于重复定义。

- OC类支持单一继承,不支持多继承；也就是说一个类只能有一个直接父类

- OC类支持多层继承 ,如下图所示

---
#super关键字

##1.super基本概念

super是个编译器的指令符号,只是告诉编译器在执行的时候,去调谁的方法.

+ self是一个隐私参数;

```
self refers to the object receiving a message in objective-C programming.
```
+ super 并不是隐藏的参数，它只是一个“编译器指示符”，它和 self 指向的是相同的消息接收者


```
super is a flag that tells the compiler to search for the method implementation in a very different place. It begins in the superclass of the class that defines the method where super appears.
```

##2.super的作用

+ 1.直接调用父类中的某个方法
+ 2.super在对象方法中，那么就会调用父类的对象方法
 super在类方法中，那么就会调用父类的类方法

+    使用场合：
    -    子类重写父类的方法时想保留父类的一些行为



#多态基本概念

##1.什么是多态?

- 什么是多态:多态就是某一类事物的多种形态

```
        猫: 猫-->动物
        狗: 狗-->动物
        男人 : 男人 -->人 -->高级动物
        女人 : 女人 -->人 -->高级动物
```
- 程序中的多态:父类指针指向子类对象

##2.多态的条件

-  有继承关系
-  子类重写父类方法
-  父类指针指向子类对象

```
    狗 *g = [狗 new];
    动物 *a = [狗 new];
    猫 *c = [猫 new];
    动物 *a = [猫 new];
```
- 表现：当父类指针指向不同的对象的时候，通过父类指针调用被重写的方法的时候，会执行该指针所指向的那个对象的方法

##3.多态的优点

- 多态的主要好处就是简化了编程接口。它允许在类和类之间重用一些习惯性的命名,而不用 为每一个新加的函数命名一个新名字。这样,编程接口就是一些抽象的行为的集合,从而和实现 接口的类的区分开来。

- 多态也使得代码可以分散在不同的对象中而不用试图在一个函数中考虑到所有可能的对象。 这样使得您的代码扩展性和复用性更好一些。当一个新的情景出现时,您无须对现有的代码进行 改动,而只需要增加一个新的类和新的同名方法。


---
#多态的实现

##1.如何实现多态

Animal是父类,子类有Cat 和 Dog,子分别重写了父类中的eat方法;实例化对象的时候可以用下 面的方法:

```
Animal *animal = nil;

//实例化猫的对象
animal = [Cat new];
[animal eat];

//实例化狗的对象
animal = [Dog new];
[animal eat];
```
##2.多态的原理

- 动态绑定:
	- 动态类型能使程序直到执行时才确定对象的真实类型
	- 动态类型绑定能使程序直到执行时才确定要对那个对象调用的方法

- OC不同于传统程序设计语言,它可以再运行时加入新的数据类型和新的程序模块:动态类型识别,动态绑定,动态加载
- id类型:通用对象指针类型,弱类型,编译时不进行具体类型检查

##3.多态的注意点

- 1. 如果存在多态,父类是可以访问子类特有的方法

```
假设 子类 Dog 有一个特有的方法bark
[dog bark];
Animal *an2 = [Dog new];
[(Dog*)an2 bark]; //把父类的指针,强制类型转换
```
- 2. 如果不存在多态,父类是不可以访问子类特有的方法的

```
Animal *an3 = [Animal new];
[(Dog*)an3 bark]; //错误的,不能强制转换
```

---
#实例变量修饰符

##1.实例变量的作用域

1. @public (公开的)在有对象的前􏰀下,任何地方都可以直接访问。
2. @protected (受保护的)只能在当前类和子类的对象方法中访问
3. @private (私有的)只能在当前类的对象方法中才能直接访问
4. @package (框架级别的)作用域介于私有和公开之间,只要处于同一个框架中相当于@public,在框架外部相当于@private

##2.变量修饰符在子类中的访问

1. @private私有成员是不能被继承,也不能被外部函数访问。
2. @public 公有成员能被继承,也能被外部方法访问。
3. @protected 保护成员能够被继承,不能够被外部函数访问。

##3.实例变量作用域使用注意事项

- 在@interface @end之间声明的成员变量如果不做特别的说明,那么其默认是protected 的。
- 一个类继承了另一个类,那么就拥有了父类的所有成员变量和方法,注意所有的成员变量它都拥有,只是有的它不能直接访问。例如@private的


---

#description方法

##1.description基本概念

- NSLog(@"%@", objectA);这会自动调用objectA的description方法来输出ObjectA的描述信息.

- description方法默认返回对象的描述信息(默认实现是返回类名和对象的内存地址)

- description方法是基类NSObject 所带的方法,因为其默认实现是返回类名和对象的内存地址, 这样的话,使用NSLog输出OC对象,意义就不是很大,因为我们并不关心对象的内存地址,比较关心的是对象内部的一些成变量的值。因此,会经常重写description方法,覆盖description方法 的默认实现

##2.description重写的方法

- 对象方法

```
/**对象方法：当使用NSLog输出该类的实例对象的时候调用*/
-(NSString *) description
{
    return [NSString stringWithFormat:@"狗腿数:%d,狗眼数%d\n",_legNum,_eyeNum];
}
```
- 类方法

```
/**类方法：当使用NSLog输出该类的类对象的时候调用*/
+(NSString *) description
{
    return @"+开头头的description方法";
}
```
##3.description陷阱

- 千万不要在description方法中同时使用%@和self,下面的写法是错误的

```
- (NSString *)description {
    return [NSString stringWithFormat:@"%@", self];
}
```
- 同时使用了%@和self,代表要调用self的description方法,因此最终会导致程序陷入死循环,循 环调用description方法

- 当[NSString stringWithFormat:@“%@”, self]; 使用它时，循坏调用，导致系统会发生运行时错误。

- 当该方法使用NSLog(“%@”,self) 时候, 系统做了相关的优化，循坏调用3次后就会自动退出

