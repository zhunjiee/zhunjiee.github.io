---
layout: post
title: "内存管理简介（MRC）"
date: 2013-10-15
comments: false
categories: ObjC
---
- Objective-c中提供了两种内存管理机制**MRC**（Mannul Reference Counting）和**ARC**(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。注意的是Xcode 4.1及其以前版本没有ARC，MRC与ARC的区别如图1所示。需要理解MRC，但实际使用时强推ARC。
![图1](https://dn-zhunjiee.qbox.me/Snip20151023_2.png)
[ARC自动内存管理请点击这里](http://www.zhunjiee.com/objc/2013/10/17/%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3ARC%E6%A6%82%E5%BF%B5.html)

##ObjC中的MRC
在MRC的内存管理模式下，与对变量的管理相关的方法有：**retain**,**release**和**autorelease**。retain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用NSAutoreleasePool对象，对加入**自动释放池**（autorelease调用）的变量进行管理，当drain时回收内存。

1. **retain**，该方法的作用是将内存数据的所有权附给另一指针变量，引用数加1，即retainCount+= 1;

2. **release**，该方法是释放指针变量对内存数据的所有权，引用数减1，即retainCount-= 1;

3. **autorelease**，该方法是将该对象内存的管理放到autoreleasepool中。


##1.内存管理的重要性
- 移动设备的内存极其有限，每个app所能占用的内存是有限制的

- 下列行为都会增加一个app的内存占用
    + 创建一个OC对象
    + 定义一个变量
    + 调用一个函数或者方法

- 当app所占用的内存较多时，系统会发出内存警告，这时得回收一些不需要再使用的内存空间。比如回收一些不需要使用的对象、变量等

- 如果app占用内存过大, 系统可能会强制关闭app, 造成闪退现象, 影响用户体验

---

##2.什么是内存管理
- 如何回收那些不需要再使用的对象?
    + 那就得学会OC的内存管理

- 所谓内存管理, 就是对内存进行管理, 涉及的操作有:
    + 分配内存 : 比如创建一个对象, 会增加内存占用
    + 清除内存 : 比如销毁一个对象, 能减小内存占用

- 内存管理的管理范围
    + 任何继承了NSObject的对象
    + 对其他非对象类型无效(int、char、float、double、struct、enum等 )

- 只有OC对象才需要进行内存管理的本质原因
    + OC对象存放于堆里面
    + 非OC对象一般放在栈里面(栈内存会被系统自动回收)

---

##3.堆和栈
- 栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。

- 堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收.

- 示例:

```

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        int a = 10; // 栈
        int b = 20; // 栈
        // p : 栈
        // Person对象(计数器==1) : 堆
        Person *p = [[Person alloc] init];
    }
    // 经过上一行代码后, 栈里面的变量a\b\c都会被回收
    // 但是堆里面的Person对象还会留在内存中,因为它是计数器依然是1
    return 0;
}

```
![](https://dn-zhunjiee.qbox.me/Snip20150608_2.png)

[更多关于堆栈信息](http://baike.baidu.com/link?url=VJz-vKfY_ASVHCB17nWR_uQ4Adhuasl2WOrW4O7ZgFdgq5Tl_kBGfUYzbNSzkSBkHAbAH8qzfDpl5Wm4rxQ1Ka)
---
# 引用计数器

##1.什么是引用计数器
- 系统是如何判断什么时候需要回收一个对象所占用的内存?
    + 根据对象的引用计数器

- 什么是引用计数器
    + 每个OC对象都有自己的引用计数器
    + 它是一个整数
    + 从字面上, 可以理解为”对象被引用的次数”
    + 也可以理解为: 它表示有多少人正在用这个对象

![](https://dn-zhunjiee.qbox.me/Snip20150624_1.png)
---

##2.引用计数器的作用
- 简单来说, 可以理解为:
    + 引用计数器表示有多少人正在使用这个对象

- 当没有任何人使用这个对象时, 系统才会回收这个对象, 也就是说
    + 当对象的引用计数器为0时,对象占用的内存就会被系统回收
    + 如果对象的计数器不为0，那么在整个程序运行过程，它占用的内存就不可能被回收(除非整个程序已经退出 )

- 任何一个对象, 刚生下来的时候, 引用计数器都为1
    + 当使用alloc、new或者copy创建一个对象时，对象的引用计数器默认就是1

---

##3.引用计数器的操作
- 要想管理对象占用的内存, 就得学会操作对象的引用计数器

- 引用计数器的常见操作
    + 给对象发送一条retain消息,可以使引用计数器值+1（retain方法返回对象本身）
    + 给对象发送一条release消息, 可以使引用计数器值-1
    + 给对象发送retainCount消息, 可以获得当前的引用计数器值

- 需要注意的是: release并不代表销毁\回收对象, 仅仅是计数器-1


---
# dealloc方法

##1.dealloc方法基本概念
- 当一个对象的引用计数器值为0时,这个对象即将被销毁，其占用的内存被系统回收
- 对象即将被销毁时系统会自动给对象发送一条dealloc消息
(因此, 从dealloc方法有没有被调用,就可以判断出对象是否被销毁)

- dealloc方法的重写
    + 一般会重写dealloc方法,在这里释放相关资源,dealloc就是对象的遗言
    + `一旦重写了dealloc方法, 就必须调用[super dealloc],并且放在最后面调用`

- 使用注意
    + 不能直接调用dealloc方法
    + 一旦对象被回收了, 它占用的内存就不再可用,坚持使用会导致程序崩溃（野指针错误）

---
# 野指针/空指针

###.概念
1. **僵尸对象**:所占用内存已经被回收的对象, 僵尸对象不能在使用
2. **野指针**: 指向僵尸对象(不可用内存)的指针, 给野指针发送消息会报错(EXE_BAD_ACCESS)
3. **空指针**: 没有指向任何东西的指针(存储的东西是nil, NULL, 0), 给空指针发送消息不会报错

##1.僵尸对象
- 已经被销毁的对象(不能再使用的对象)

##2.野指针
- 指向僵尸对象(不可用内存)的指针
- 给野指针发消息会报EXC_BAD_ACCESS错误

##3.空指针
- 没有指向存储空间的指针(里面存的是nil, 也就是0)
- 给空指针发消息是没有任何反应的

- 为了避免野指针错误的常见办法
    + 在对象被销毁之后, 将指向对象的指针变为空指针

---
# 内存管理原则


##1.内存管理原
- 苹果官方规定的内存管理原则
    + 谁创建谁release :
        * 如果你通过alloc、new或[mutable]copy来创建一个对象，那么你必须调用release或autorelease

    + 谁retain谁release:
        * 只要你调用了retain，就必须调用一次release

- 总结一下就是
    + 有加就有减
    + 曾经让对象的计数器+1，就必须在最后让对象计数器-1

---

##2.多对象内存管理
- 单个对象的内存管理, 看起来非常简单

- 如果对多个对象进行内存管理, 并且对象之间是有联系的, 那么管理就会变得比较复杂

- 其实, 多个对象的管理思路 跟很多游戏的房间管理差不多
    + 比如斗地主 \ 劲舞团 \ QQ音速


- 总的来说, 有这么几点管理规律
    + 只要还有人在用某个对象，那么这个对象就不会被回收
    + 只要你想用这个对象，就让对象的计数器+1
    + 当你不再使用这个对象时，就让对象的计数器-1


---

##3.setter方法内存管理
- (1)retain需要使用的对象
- (2)release之前的对象
- (3)只有传入的对象和之前的不同才需要release和retain

```
- (void)setRoom:(Room *)room
{
    // 避免过度释放
    if (room != _room)
    {
        // 对当前正在使用的车（旧车）做一次release
        [_room release];

        // 对新车做一次retain操作
         _room = [room retain];
    }
}

```

##4.dealloc方法的内存管理

```
- (void)dealloc
{
    // 当人不在了，代表不用房间了
    // 对房间做一次release操作
    [_room release];
    [super dealloc];
}

```
