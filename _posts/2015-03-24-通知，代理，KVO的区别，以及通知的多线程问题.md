---
layout: post
title: "通知，代理，KVO的区别，以及通知的多线程问题"
date: 2015-03-24
comments: false
categories: 知识囊
---
##通知，代理，KVO的区别，以及通知的多线程问题
###1. 通知，代理，KVO的区别
首先说明，通知、代理、KVO所实现的功能都是一样的，就是在尽量减少耦合的情况下，一个对象传递事件给另一个对象，三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法，并对事件作出恰当的处理。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。####代理- 说到代理模式，举一个最简单的例子，如果一个婴儿饿了，他又不能自己做东西吃，他会通过哭声传递他饿了，这就相当于代理中定义一个协议，声明一些代理的方法。- 这时候得需要别人帮忙，找人也不能随便找人，这个人是他的父母，雇佣的保姆也可以，能喂婴儿的必须满足什么条件，这和代理模式中想要成为代理必须遵循代理协议是一样的。- 只有遵循了代理协议，才可以调用相关的代理方法，在代理方法中去实现一些功能。delegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。
- delegate的优势：	- 1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。	- 2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误	- 3.协议必须在controller的作用域范围内定义	- 4.在一个应用中的控制流程是可跟踪的并且是可识别的；	- 5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates	- 6.没有第三方对象要求保持/监视通信过程。	- 7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller- 缺点：	- 1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义	- 2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash	- 3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。####通知在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。它允许我们在低程度耦合的情况下，满足控制器与一个任意的对象进行通信的目的。这种模式的基本特征是为了让其他的对象能够接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称）。这样对于controller来说是匿名的，其他的使用同样的key来注册了该通知的对象（即观察者）能够对通知的事件作出反应。- 优势：	- 1.不需要编写多少代码，实现比较简单；	- 2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单	- 3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息- 缺点：	- 1.在编译期不会检查通知是否能够被观察者正确的处理； 	- 2.在释放注册的对象时，需要在通知中心取消注册；	- 3.在调试的时候应用的工作以及控制过程难跟踪；	- 4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系；	- 5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；	- 6.通知发出后，controller不能从观察者获得任何的反馈信息。
        

####KVOKVO——key value observe:键值观察模式，是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不用在controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它**只能用来对属性作出反应，而不会用来对方法或者动作作出反应**。- 优点：	- 1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；	- 2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；	- 3.能够提供观察的属性的最新值以及先前值；	- 4.用key paths来观察属性，因此也可以观察嵌套对象；	- 5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察- 缺点：	- 1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；	- 2.对属性重构将导致我们的观察代码不再可用；	- 3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；	- 4.当释放观察者时不需要移除观察者。综上所述：
1.	通知比较灵活(1个通知能被多个对象接收, 1个对象能接收多个通知),2.	代理比较规范，但是代码多(默认是1对1)3.	KVO性能不好(底层会动态产生新的类)，只能监听某个对象属性的改变, 不推荐使用(1个对象的属性能被多个对象监听,  1个对象能监听多个对象的其他属性)###何时使用？
- 根据我的开发经验，如果是属性层的事件，如监听某个对象的某一属性的改变，我会使用KVO观察模式。
- 对于其他的事件，我会尽量使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。
###2. 通知的多线程问题- 一般情况，Notification的发送和接收处理都是在同一个线程中进行的，当然苹果也允许我们在不同的线程中post和转发一个Notification，这里需要运用到“重定向”思想。
- 苹果之所以采取通知中心在同一个线程中post和转发同一消息这一策略，应该是出于线程安全的角度来考量的。官方文档告诉我们，NSNotificationCenter是一个线程安全类，我们可以在多线程环境下使用同一个NSNotificationCenter对象而不需要加锁。
- 然而将消息的发送和消息的移除放在不同的线程中进行处理，会报一个很经典的错误：EXC_BAD_ACCESS。
- NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，尽量在同一个线程中处理Notification的发送和接收处理，避免出现上面的线程问题。